/**
 * Testes do Design System - KorLab Nutri
 * Valida√ß√£o de consist√™ncia visual, cores, tipografia e espa√ßamentos
 */

const { test, expect } = require('@playwright/test');
const DesignHelper = require('../helpers/design.helper.cjs');

// P√°ginas para validar design system
const pagesToTest = [
  { name: 'dashboard', path: '/' },
  { name: 'clientes', path: '/clientes' },
  { name: 'questionarios', path: '/questionarios' },
  { name: 'planos-alimentares', path: '/planos' },
  { name: 'configuracoes', path: '/configuracoes' }
];

test.describe('Design System - KorLab Nutri', () => {
  let designHelper;

  test.beforeEach(async ({ page }) => {
    designHelper = new DesignHelper(page);
    
    // Fazer login antes dos testes
    await page.goto('/login');
    await page.waitForLoadState('networkidle');
    
    try {
      await page.fill('input[name="email"]', 'nutricionista@kornutri.com');
      await page.fill('input[name="password"]', 'Nutri123!');
      await page.click('button[type="submit"]');
      await page.waitForLoadState('networkidle');
    } catch (error) {
      console.warn('‚ö†Ô∏è Login autom√°tico falhou, continuando sem autentica√ß√£o');
    }
  });

  // Teste de paleta de cores
  test('deve ter paleta de cores consistente', async ({ page }) => {
    console.log('üé® Testando paleta de cores...');
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    const colorPalette = await designHelper.extractColorPalette();
    
    // Verificar se n√£o h√° muitas cores (m√°ximo 20 cores √∫nicas)
    expect(colorPalette.uniqueColors.length).toBeLessThanOrEqual(20);
    
    // Verificar se h√° cores suficientes (m√≠nimo 5)
    expect(colorPalette.uniqueColors.length).toBeGreaterThanOrEqual(5);
    
    console.log(`‚úÖ Paleta de cores: ${colorPalette.uniqueColors.length} cores √∫nicas`);
  });

  // Teste de tipografia
  test('deve ter tipografia consistente', async ({ page }) => {
    console.log('üìù Testando tipografia...');
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    const typography = await designHelper.validateTypography();
    
    // Verificar consist√™ncia da tipografia
    expect(typography.analysis.consistency.isConsistent).toBe(true);
    
    // Verificar n√∫mero de fontes (m√°ximo 3)
    expect(typography.analysis.consistency.fontFamilyCount).toBeLessThanOrEqual(3);
    
    // Verificar n√∫mero de tamanhos (m√°ximo 8)
    expect(typography.analysis.consistency.fontSizeCount).toBeLessThanOrEqual(8);
    
    console.log(`‚úÖ Tipografia: ${typography.analysis.consistency.fontFamilyCount} fontes, ${typography.analysis.consistency.fontSizeCount} tamanhos`);
  });

  // Teste de espa√ßamentos
  test('deve ter espa√ßamentos consistentes', async ({ page }) => {
    console.log('üìè Testando espa√ßamentos...');
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    const spacing = await designHelper.validateSpacing();
    
    // Verificar consist√™ncia dos espa√ßamentos
    expect(spacing.analysis.isConsistent).toBe(true);
    
    // Verificar n√∫mero de valores √∫nicos (m√°ximo 10)
    expect(spacing.analysis.uniqueValues.length).toBeLessThanOrEqual(10);
    
    console.log(`‚úÖ Espa√ßamentos: ${spacing.analysis.uniqueValues.length} valores √∫nicos`);
  });

  // Teste de componentes visuais
  test('deve ter componentes visuais consistentes', async ({ page }) => {
    console.log('üß© Testando componentes visuais...');
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    const components = await designHelper.validateVisualComponents();
    
    // Verificar consist√™ncia dos bot√µes
    expect(components.analysis.buttons.isConsistent).toBe(true);
    
    // Verificar consist√™ncia dos inputs
    expect(components.analysis.inputs.isConsistent).toBe(true);
    
    // Verificar consist√™ncia dos cards
    expect(components.analysis.cards.isConsistent).toBe(true);
    
    console.log(`‚úÖ Componentes: ${components.data.length} componentes analisados`);
  });

  // Teste de design responsivo
  test('deve ser responsivo em diferentes viewports', async ({ page }) => {
    console.log('üì± Testando design responsivo...');
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    const responsiveResults = await designHelper.validateResponsiveDesign();
    
    // Verificar se testou todos os viewports
    expect(responsiveResults.length).toBe(3);
    
    // Verificar se h√° elementos vis√≠veis em cada viewport
    responsiveResults.forEach(result => {
      expect(result.visibleElements).toBeGreaterThan(0);
    });
    
    console.log(`‚úÖ Design responsivo: ${responsiveResults.length} viewports testados`);
  });

  // Teste completo do design system
  test('deve passar valida√ß√£o completa do design system', async ({ page }) => {
    console.log('üìä Executando valida√ß√£o completa...');
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    const report = await designHelper.generateDesignSystemReport();
    
    // Verificar pontua√ß√£o geral (m√≠nimo 80/100)
    expect(report.summary.overallScore).toBeGreaterThanOrEqual(80);
    
    // Verificar consist√™ncia geral
    expect(report.summary.typographyConsistent).toBe(true);
    expect(report.summary.spacingConsistent).toBe(true);
    expect(report.summary.componentConsistent).toBe(true);
    expect(report.summary.responsiveTested).toBe(true);
    
    console.log(`‚úÖ Design System: ${report.summary.overallScore}/100 pontos`);
  });

  // Teste de consist√™ncia entre p√°ginas
  test('deve manter consist√™ncia visual entre p√°ginas', async ({ page }) => {
    console.log('üîÑ Testando consist√™ncia entre p√°ginas...');
    
    const colorPalettes = [];
    const typographyData = [];
    
    for (const pageInfo of pagesToTest) {
      await page.goto(pageInfo.path);
      await page.waitForLoadState('networkidle');
      
      const colors = await designHelper.extractColorPalette();
      const typography = await designHelper.validateTypography();
      
      colorPalettes.push({
        page: pageInfo.name,
        colors: colors.uniqueColors
      });
      
      typographyData.push({
        page: pageInfo.name,
        fonts: typography.analysis.fontFamilies,
        sizes: typography.analysis.fontSizes
      });
    }
    
    // Verificar consist√™ncia de cores entre p√°ginas
    const allColors = colorPalettes.flatMap(p => p.colors);
    const uniqueColorsAcrossPages = [...new Set(allColors)];
    
    // N√£o deve haver mais de 25 cores √∫nicas em todas as p√°ginas
    expect(uniqueColorsAcrossPages.length).toBeLessThanOrEqual(25);
    
    // Verificar consist√™ncia de tipografia
    const allFonts = typographyData.flatMap(t => t.fonts);
    const uniqueFonts = [...new Set(allFonts)];
    
    // N√£o deve haver mais de 3 fontes √∫nicas
    expect(uniqueFonts.length).toBeLessThanOrEqual(3);
    
    console.log(`‚úÖ Consist√™ncia entre p√°ginas: ${uniqueColorsAcrossPages.length} cores, ${uniqueFonts.length} fontes`);
  });

  // Teste de acessibilidade visual
  test('deve ter contraste adequado em todos os elementos', async ({ page }) => {
    console.log('üëÅÔ∏è Testando contraste visual...');
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    // Verificar contraste de elementos de texto
    const contrastData = await page.evaluate(() => {
      const elements = document.querySelectorAll('h1, h2, h3, h4, h5, h6, p, span, a, button, label');
      const results = [];
      
      elements.forEach(el => {
        const text = el.textContent?.trim();
        if (text && text.length > 0) {
          const styles = window.getComputedStyle(el);
          const color = styles.color;
          const backgroundColor = styles.backgroundColor;
          
          if (color && backgroundColor && color !== backgroundColor) {
            results.push({
              element: el.tagName,
              color,
              backgroundColor,
              text: text.slice(0, 20)
            });
          }
        }
      });
      
      return results;
    });
    
    // Verificar se h√° elementos com contraste
    expect(contrastData.length).toBeGreaterThan(0);
    
    console.log(`‚úÖ Contraste visual: ${contrastData.length} elementos verificados`);
  });

  // Teste de performance visual
  test('deve carregar elementos visuais rapidamente', async ({ page }) => {
    console.log('‚ö° Testando performance visual...');
    
    const startTime = Date.now();
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    const loadTime = Date.now() - startTime;
    
    // Verificar se carregou em menos de 3 segundos
    expect(loadTime).toBeLessThan(3000);
    
    // Verificar se h√° elementos visuais carregados
    const visualElements = await page.$$eval('*', elements => {
      return elements.filter(el => {
        const rect = el.getBoundingClientRect();
        return rect.width > 0 && rect.height > 0;
      }).length;
    });
    
    expect(visualElements).toBeGreaterThan(10);
    
    console.log(`‚úÖ Performance visual: ${loadTime}ms, ${visualElements} elementos`);
  });

  // Teste de layout em diferentes resolu√ß√µes
  test('deve manter layout adequado em diferentes resolu√ß√µes', async ({ page }) => {
    console.log('üñ•Ô∏è Testando layout em diferentes resolu√ß√µes...');
    
    const resolutions = [
      { name: 'HD', width: 1366, height: 768 },
      { name: 'Full HD', width: 1920, height: 1080 },
      { name: '4K', width: 3840, height: 2160 }
    ];
    
    const results = [];
    
    for (const resolution of resolutions) {
      await page.setViewportSize({ width: resolution.width, height: resolution.height });
      await page.goto('/');
      await page.waitForLoadState('networkidle');
      
      const layoutInfo = await page.evaluate(() => {
        const body = document.body;
        const rect = body.getBoundingClientRect();
        
        return {
          width: rect.width,
          height: rect.height,
          hasHorizontalScroll: document.documentElement.scrollWidth > window.innerWidth,
          hasVerticalScroll: document.documentElement.scrollHeight > window.innerHeight
        };
      });
      
      results.push({
        resolution: resolution.name,
        ...layoutInfo
      });
    }
    
    // Verificar se n√£o h√° scroll horizontal em nenhuma resolu√ß√£o
    const hasHorizontalScroll = results.some(r => r.hasHorizontalScroll);
    expect(hasHorizontalScroll).toBe(false);
    
    console.log(`‚úÖ Layout responsivo: ${results.length} resolu√ß√µes testadas`);
  });
});
